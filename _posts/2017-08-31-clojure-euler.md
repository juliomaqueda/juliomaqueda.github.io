---
layout: post
title: Clojure solutions for project euler
description: Clojure solutions for project euler
date:  2017-08-31
time: 20 mins
tags: clojure
language: english
---

There is nothing better when learning a new programming language than getting your hands dirty trying to solve actual problems. Here is where [Project euler](https://projecteuler.net/) comes to be a great ally, with more than 700 problems ready to challenge you.

In this series, we'll start resolving exercises as long as it's fun!

We'll be using [Criterium](https://github.com/hugoduncan/criterium) for benchmarking on the JVM.

<!-- more -->

## Problem 1 - Multiples of 3 and 5

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

Nothing special, right? We just need to sum up the multiples of 3 plus the multiples of 5, remembering to subtract the multiples of 15 because they are counted twice.

```clojure
(defn euler-001 [limit]
  (let [limit (dec limit)
        sum-1n #(/ (* % (inc %)) 2)
        num-multiples #(int (/ limit %))
        sum-multiples #(* % (sum-1n (num-multiples %)))]
    (- (+ (sum-multiples 3) (sum-multiples 5)) (sum-multiples 15))))

;; Benchmark: 547.421619 ns (110638560 evaluations in 60 samples)
```

We defined 3 partial functions:
- `sum-1n` sums up all numbers below the received number (included)
- `num-multiples` calculates the number of multiples
- `sum-multiples` sum all multiples

## Problem 2 - Even Fibonacci numbers

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

Easy loop, ensuring the fib number is even before adding it to the result.

```clojure
(defn euler-002 [limit]
  (loop [first 1 second 1 even-sum 0]
    (let [next-val (+ first second)]
      (if (> next-val limit)
        even-sum
        (recur next-val
               first
               (if (even? next-val)
                 (+ even-sum next-val)
                 even-sum))))))

;; Benchmark: 215.761263 ns (286510020 evaluations in 60 samples)
```

## Problem 3 - Largest prime factor

> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143 ?

What a blast from the past! Let's decompose this little boy in prime factors like in primary school and return the max value.

```clojure
(defn euler-003 [num]
  (loop [factor 2 target num max-factor num]
    (if (> factor target)
      max-factor
      (if (zero? (mod target factor))
        (recur factor (/ target factor) factor)
        (recur (if (odd? factor) (+ factor 2) (inc factor)) target max-factor)))))

;; Benchmark: 81.065932 µs (758040 evaluations in 60 samples)
```

We start dividing by 2, reusing the `factor` while it keeps dividing our `target`. Otherwise, we increment the `factor` to the next odd number.

## Problem 4 - Largest palindrome product

> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
>
> Find the largest palindrome made from the product of two 3-digit numbers.

There are a couple of considerations here. The palindrome is made from the product of two 3-digit numbers, meaning the range is narrowed down to `100^2 <= n <= 999^2`. In addition to that, the number must be reversible.

```clojure
(defn- is-reversible? [num]
  (= num (Integer. (clojure.string/reverse (str num)))))

(defn- has-dividers? [num]
  (some #(zero? (mod num %)) (range 999 (dec (int (Math/sqrt num))) -1)))

(defn euler-004 []
  (first (filter #(and (is-reversible? %) (has-dividers? %))
                 (range (* 999 999) (dec (* 100 100)) -1))))

;; Benchmark: 9.938761 ms (5940 evaluations in 60 samples)
```

In the `has-dividers?` function, we just need to test numbers between 999 and the square of the received number because we already know its range (the worst case would be the square of `100 * 100`, that is our minimum 3-digit number).

## Problem 5 - Smallest multiple

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
>
> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

Back to school again! We're basically asked to find the least common multiple for all numbers between 1 and 20. Another way to formulate this problem would be finding all prime numbers between 1 and 20 at their maximum exponent (not exceeding 20), and getting the final product.

```clojure
(defn- prime? [num]
  (or (= num 2)
      (not-any? #(zero? (mod num %)) (cons 2 (range 3 (inc (Math/sqrt num)) 2)))))

(defn- max-exp [num limit]
  (loop [max-num num]
    (let [next-num (* max-num num)]
      (if (> next-num limit) max-num (recur next-num)))))

(defn euler-005 [limit]
  (->> (range limit 1 -1)
       (filter prime?)
       (map #(max-exp % limit))
       (reduce *)))

;; Benchmark: 4.128371 µs (14970840 evaluations in 60 samples)
```

## Problem 6 - Sum square difference

> The sum of the squares of the first ten natural numbers is
>
> 1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385
>
> The square of the sum of the first ten natural numbers is
>
> (1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025
>
> Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
>
> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

We'll reuse the `sum-1n` function created for [Problem 1](#problem-1---multiples-of-3-and-5) to get the square of the sum. For the sum of the squares, we just need to apply a square function over all elements below 100.

```clojure
(defn- sum-1n [num]
  (/ (* num (inc num)) 2))

(defn euler-006 [limit]
  (- (#(* % %) (sum-1n limit))
     (reduce + (map #(* % %) (range limit 0 -1)))))

;; Benchmark: 5.123187 µs (11845080 evaluations in 60 samples)
```

## Problem 7 - 10001st prime

> By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
>
> What is the 10001st prime number?

Probably not the most efficient approach but we'll reuse the `prime?` function we used for [Problem 5](#problem-5---smallest-multiple).

```clojure
(defn- prime? [num]
  (or (= num 2)
      (not-any? #(zero? (mod num %)) (cons 2 (range 3 (inc (Math/sqrt num)) 2)))))

(defn euler-007 [pos]
  (loop [current-num 3 current-pos 2]
    (if (= pos current-pos)
      current-num
      (let [next-num (+ current-num 2)]
        (recur next-num (if (prime? next-num) (inc current-pos) current-pos))))))

;; Benchmark: 134.415686 ms (480 evaluations in 60 samples)
```

## Problem 8 - Largest product in a series

> The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
>
> ```
> 73167176531330624919225119674426574742355349194934
> 96983520312774506326239578318016984801869478851843
> 85861560789112949495459501737958331952853208805511
> 12540698747158523863050715693290963295227443043557
> 66896648950445244523161731856403098711121722383113
> 62229893423380308135336276614282806444486645238749
> 30358907296290491560440772390713810515859307960866
> 70172427121883998797908792274921901699720888093776
> 65727333001053367881220235421809751254540594752243
> 52584907711670556013604839586446706324415722155397
> 53697817977846174064955149290862569321978468622482
> 83972241375657056057490261407972968652414535100474
> 82166370484403199890008895243450658541227588666881
> 16427171479924442928230863465674813919123162824586
> 17866458359124566529476545682848912883142607690042
> 24219022671055626321111109370544217506941658960408
> 07198403850962455444362981230987879927244284909188
> 84580156166097919133875499200524063689912560717606
> 05886116467109405077541002256983155200055935729725
> 71636269561882670428252483600823257530420752963450
> ```
> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

Let's loop over a digitalized version of the input string with `Character/digit` and start taking segments of 13 digits until we get the max product.

```clojure
(defn euler-008 [input block-size]
  (loop [numbers (map #(Character/digit % 10) input) max-prod 0]
    (let [[first & more] numbers segment (take block-size numbers)]
      (if (< (count segment) block-size)
        max-prod
        (let [new-prod (reduce * segment)]
          (recur more (if (> new-prod max-prod) new-prod max-prod)))))))

;; Benchmark: 5.896815 ms (10560 evaluations in 60 samples)
```

## Problem 9 - Special Pythagorean triplet

> A Pythagorean triplet is a set of three natural numbers, a < b < c, for which
>
> a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>
>
> For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.
>
> There exists exactly one Pythagorean triplet for which a + b + c = 1000.
>
> Find the product abc.

Per the problem description, we can get the required triangle is a right triangle. Also, the last bit is important because provides the triangle's perimeter. Knowing the perimeter `p` and the value of the cathetus `a`, we can apply the formula below to get the other cathetus `b`:

> b = [(p - a)<sup>2</sup> - a<sup>2</sup>] / 2 (p - a)

Once obtained, if the result is an integer number we can assume the hypotenuse is an integer as well (per Pythagorean theorem), and we'd be done because there is only one valid triplet.

As a minor improvement, there is no need to test all possible sizes for the first cathetus. If the perimeter is an odd number it means at least one of the cathetus must be odd. On the other hand, if the perimeter is even at least one of the cathetus must be even.

We won't worry about the cathetus we're working on. Will just loop over the possible values for the even-or-odd cathetus and calculate the value of the other cathetus that matches the perimeter.

```clojure
(defn- other-triangle-side-size [side-size perim]
  (let [other-sizes (- perim side-size)
        div1 (- (* other-sizes other-sizes) (* side-size side-size))
        div2 (* 2 other-sizes)]
    (/ div1 div2)))

(defn euler-009 [perim]
  (loop [side-size (if (odd? perim) 1 2)]
    (if (< side-size perim)
      (let [other-side-size (other-triangle-side-size side-size perim)]
        (if (integer? other-side-size)
          (* side-size other-side-size (- perim side-size other-side-size))
          (recur (+ side-size 2)))))))

;; Benchmark: 22.463785 µs (2388900 evaluations in 60 samples)
```

In the above solution, `div1` and `div2` are the dividend and divisor of the aforementioned formula to get the second cathetus.
